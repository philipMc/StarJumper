/*
-----------------------------------------------------------------------------
Filename:    test.cpp
-----------------------------------------------------------------------------


This source file is generated by the
   ___                   _              __    __ _                  _ 
  /___\__ _ _ __ ___    /_\  _ __  _ __/ / /\ \ (_)______ _ _ __ __| |
 //  // _` | '__/ _ \  //_\\| '_ \| '_ \ \/  \/ / |_  / _` | '__/ _` |
/ \_// (_| | | |  __/ /  _  \ |_) | |_) \  /\  /| |/ / (_| | | | (_| |
\___/ \__, |_|  \___| \_/ \_/ .__/| .__/ \/  \/ |_/___\__,_|_|  \__,_|
      |___/                 |_|   |_|                                 
      Ogre 1.7.x Application Wizard for VC10 (July 2011)
      http://code.google.com/p/ogreappwizards/
-----------------------------------------------------------------------------
*/

#include "Test.h"

//-------------------------------------------------------------------------------------
Test::Test():
mPlayer(0)
{
	cameraMin = 40;
	cameraMax = 40;
}
//-------------------------------------------------------------------------------------
Test::~Test()
{	
}

//-------------------------------------------------------------------------------------
void Test::createScene(void)
{
	//create the nodes for the player
	//overrall player parent node
	Ogre::SceneNode* parentBodyNode = mSceneMgr->getRootSceneNode()->createChildSceneNode("bodyParentNode");
	parentBodyNode->attachObject(mCamera);
	//child node that body is attached to
	Ogre::SceneNode * playerBodyNode = parentBodyNode->createChildSceneNode("playerBodyNode");
	//Body 
    Ogre::Entity* body = mSceneMgr->createEntity("body", "body.mesh");
	playerBodyNode->attachObject(body);
	playerBodyNode->scale(10,10,10);
	parentBodyNode->setPosition(0,5,0);	
	mCamera->lookAt(Ogre::Vector3(parentBodyNode->getPosition())); 

	//create player
	mPlayer = new Player(mSceneMgr,0);	

	//create pick up manager which internally creates pick ups
	mPickUpManager = new PickUpManager(mSceneMgr);
	
	//start platform
	Ogre::Entity* platform1 = mSceneMgr->createEntity("platform1", "Cube.mesh");
	platform1->setMaterialName("Examples/Rockwall");
	Ogre::SceneNode* Plat1Node = mSceneMgr->getRootSceneNode()->createChildSceneNode("Plat1Node");
	
    Plat1Node->attachObject(platform1);
	Plat1Node->scale(0.2,0.1,0.2);
	Plat1Node->setPosition(0,0,0);
	Plat1Node->yaw(Ogre::Degree(180));

	Ogre::Entity* platform2 = mSceneMgr->createEntity("platform2", "Cube.mesh");
	platform2->setMaterialName("Examples/Rockwall");
	Ogre::SceneNode* Plat2Node = mSceneMgr->getRootSceneNode()->createChildSceneNode("Plat2Node");
	
    Plat2Node->attachObject(platform2);
	Plat2Node->scale(0.2,0.1,0.2);
	Plat2Node->setPosition(0,0,40);
	Plat2Node->yaw(Ogre::Degree(180));

	Ogre::Entity* platform3 = mSceneMgr->createEntity("platform3", "Cube.mesh");
	platform3->setMaterialName("Examples/Rockwall");
	Ogre::SceneNode* Plat3Node = mSceneMgr->getRootSceneNode()->createChildSceneNode("Plat3Node");
	
    Plat3Node->attachObject(platform3);
	Plat3Node->scale(0.2,0.1,0.2);
	Plat3Node->setPosition(0,10,80);
	Plat3Node->yaw(Ogre::Degree(180));

	Ogre::Entity* platform4 = mSceneMgr->createEntity("platform4", "Cube.mesh");
	platform4->setMaterialName("Examples/Rockwall");
	Ogre::SceneNode* Plat4Node = mSceneMgr->getRootSceneNode()->createChildSceneNode("Plat4Node");
	
    Plat4Node->attachObject(platform4);
	Plat4Node->scale(0.2,0.1,0.2);
	Plat4Node->setPosition(0,0,170);
	Plat4Node->yaw(Ogre::Degree(180));

/////////////////	PLANE	/////////////////////////////////////////	
 	Ogre::Plane plane;
    plane.normal = Ogre::Vector3::UNIT_Y;
	// horizontal plane with normal up in y-direction
   	plane.d = 0;//Plane passes through the origin i.e. plane at y = 0
    Ogre::MeshManager::getSingleton().createPlane("floor", Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME, plane,
            1000,1000,10,10,true,1,10,10,Ogre::Vector3::UNIT_Z);
   	Ogre::Entity* pPlaneEnt = mSceneMgr->createEntity("plane", "floor");
    pPlaneEnt->setMaterialName("Examples/space");
   	pPlaneEnt->setCastShadows(false);
	Ogre::SceneNode* floorNode = mSceneMgr->createSceneNode("floor1");
	mSceneMgr->getRootSceneNode()->addChild(floorNode);
	floorNode->attachObject(pPlaneEnt);
	//////////////////////////////////////////////////////////////////////

    // Set ambient light
    mSceneMgr->setAmbientLight(Ogre::ColourValue(0.5, 0.5, 0.5));

    // Create a light
    Ogre::Light* l = mSceneMgr->createLight("MainLight");
    l->setPosition(20,80,50);
  

	bool onPlat  = false;
	//make debugDrawer instanc
	
	new DebugDrawer(mSceneMgr, 0.5f);

	/////////////	SOUND	//////////////////////////////////////////////////////////
	//3D listener 
	FMOD_VECTOR listenerVel = {mPlayer->getDirection().x, mPlayer->getDirection().y, mPlayer->getDirection().z};
	FMOD_VECTOR listenerPos = {mPlayer->getPosition().x, mPlayer->getPosition().y, mPlayer->getPosition().z};
	SoundManager::instance()->System()->set3DListenerAttributes(0, &listenerPos, &listenerVel, 0, 0);

	//3D source 
	listener = true;
	sourceChannel = 0;
	Vector3 source = mPickUpManager->getPickUp(3)->getPosition();
	SoundManager::instance()->System()->playSound(FMOD_CHANNEL_FREE, SoundManager::instance()->getConst(), false, &sourceChannel);
	FMOD_VECTOR sourcePos = {source.x, source.y, source.z};
	sourceChannel->set3DAttributes(&sourcePos, 0);
	sourceChannel->setVolume(0.9f);
	sourceChannel->set3DMinMaxDistance(50, 10000);

	//reverb
	reverbOn = true;
	SoundManager::instance()->setReverb(mPickUpManager->getPickUp(4));

	backGroundMusic = true;
	effects = true;

	//background music start up and go
	SoundManager::instance()->playBackground();

}

bool Test::keyPressed(const OIS::KeyEvent &arg )
{
	Ogre::Vector3 currentPos = mPlayer->getParentNode()->getPosition();
	Ogre::Vector3 minPos = getCameraMinPos();
	Ogre::Vector3 maxPos = getCameraMaxPos();
	if (arg.key == OIS::KC_RIGHT)
	{
		mPlayer->setMove(mPlayer->getMoveMod() * 15);	
	}
	if (arg.key == OIS::KC_LEFT)
	{		
		mPlayer->setMove(mPlayer->getMoveMod() * -15);		
	}
	if (arg.key == OIS::KC_ESCAPE)
    {
        mShutDown = true;
    }
	if(arg.key == OIS::KC_SPACE)   // refresh all textures
    {		
		mPlayer->setJump(true);
    }

	//Sound key presses
	if(arg.key == OIS::KC_M)//turn on/off background music
	{
		if(backGroundMusic == true)
			backGroundMusic = false;
		else
			backGroundMusic = true;
	}
	if(arg.key == OIS::KC_L)//turn on/off 3d listener and source
	{
		if(listener == true)
			listener = false;
		else
			listener = true;
	}
	if(arg.key == OIS::KC_E)//turn on/off audio effects
	{
		if(effects == true)
			effects = false;
		else
			effects = true;
	}
	if(arg.key == OIS::KC_R)//turn on/off reverb
	{
		if(reverbOn == true)
			reverbOn = false;
		else
			reverbOn = true;
	}


	//System handled keypresses
    if (mTrayMgr->isDialogVisible()) return true;   // don't process any more keys if dialog is up

    if (arg.key == OIS::KC_F)   // toggle visibility of advanced frame stats
    {
        mTrayMgr->toggleAdvancedFrameStats();
    }
    else if (arg.key == OIS::KC_G)   // toggle visibility of even rarer debugging details
    {
        if (mDetailsPanel->getTrayLocation() == OgreBites::TL_NONE)
        {
            mTrayMgr->moveWidgetToTray(mDetailsPanel, OgreBites::TL_TOPRIGHT, 0);
            mDetailsPanel->show();
        }
        else
        {
            mTrayMgr->removeWidgetFromTray(mDetailsPanel);
            mDetailsPanel->hide();
        }
    }
    
    else if(arg.key == OIS::KC_F5)   // refresh all textures
    {
        Ogre::TextureManager::getSingleton().reloadAll();
    }
	
    else if (arg.key == OIS::KC_SYSRQ)   // take a screenshot
    {
        mWindow->writeContentsToTimestampedFile("screenshot", ".jpg");
    }  
    
    return true;
}
bool Test::keyReleased( const OIS::KeyEvent &arg )
{
	if(arg.key == OIS::KC_SPACE)
	{
		//mPlayer->setJump(false);		
	}
	if (arg.key == OIS::KC_RIGHT)
	{
		mPlayer->setMove(0);
	}
	if (arg.key == OIS::KC_LEFT)
	{
		mPlayer->setMove(0);
	}    
    return true;
}

bool Test::frameRenderingQueued(const Ogre::FrameEvent& evt)
{   if(mWindow->isClosed())
        return false;

    if(mShutDown)
        return false;

    //Need to capture/update each device
    mKeyboard->capture();
    mMouse->capture();

    mTrayMgr->frameRenderingQueued(evt);

	mPlayer->update(evt.timeSinceLastFrame);
    if (!mTrayMgr->isDialogVisible())
    {
        mCameraMan->frameRenderingQueued(evt);   // if dialog isn't up, then update the camera
        if (mDetailsPanel->isVisible())   // if details panel is visible, then update its contents
        {
            mDetailsPanel->setParamValue(0, Ogre::StringConverter::toString(mPlayer->getLives()));
            mDetailsPanel->setParamValue(1, Ogre::StringConverter::toString(mPlayer->getJumpMod()));
            mDetailsPanel->setParamValue(2, Ogre::StringConverter::toString(mPlayer->getMoveMod()));
            mDetailsPanel->setParamValue(4, Ogre::StringConverter::toString(mPlayer->getTimeLeft()));
            mDetailsPanel->setParamValue(5, Ogre::StringConverter::toString(mPlayer->getPosition().x));
            mDetailsPanel->setParamValue(6, Ogre::StringConverter::toString(mPlayer->getPosition().y));
            mDetailsPanel->setParamValue(7, Ogre::StringConverter::toString(mPlayer->getPosition().z));
        }
    }

	//check collision with pick ups
	CollisionManager * cm = CollisionManager::instance();
	Ogre::Entity * player = mPlayer->getEnt();
	for (int i = 0; i < 3; i++)
	{
		Ogre::Entity * pickUp = mPickUpManager->getPickUp(i)->getEntity();
		bool colliding = cm->checkCollisionsWithPickUps(player, pickUp);
		if (colliding == true)
		{
			String t = mPickUpManager->getPickUp(i)->getType();
			if(t == "jump") {				
				if (mPlayer->getCurrentPickUp() != "")
					mPlayer->resetMoveMod();
				mPlayer->setJumpMod();
				mPlayer->setCurrentPickUp(t);
			}
			else if(t == "move") {
				if (mPlayer->getCurrentPickUp() != "")
					mPlayer->resetJumpMod();
				mPlayer->setMoveMod();
				mPlayer->setCurrentPickUp(t);
			}
			else
				mPlayer->setLives(1);
			mPickUpManager->getPickUp(i)->reset();
		}
	}
	//check if sound needs to be updated
	if (listener == true)
	{
		sourceChannel->setMute(false);
		FMOD_VECTOR listenerVel = {mPlayer->getDirection().x, mPlayer->getDirection().y, mPlayer->getDirection().z};
		FMOD_VECTOR listenerPos = {mPlayer->getPosition().x, mPlayer->getPosition().y, mPlayer->getPosition().z};
		SoundManager::instance()->System()->set3DListenerAttributes(0, &listenerPos, &listenerVel, 0, 0);

		Vector3 source = mPickUpManager->getPickUp(3)->getPosition();	
		FMOD_VECTOR sourcePos = {source.x, source.y, source.z};
		sourceChannel->set3DAttributes(&sourcePos, 0);
	}
	else
		sourceChannel->setMute(true);

	if(backGroundMusic == true) {
		SoundManager::instance()->getBGChannel()->setPaused(false);		
	}
	
	else
		SoundManager::instance()->getBGChannel()->setPaused(true);

	if (reverbOn == true) {
		SoundManager::instance()->getReverb()->setActive(true);
		FMOD_REVERB_PROPERTIES revProp = FMOD_PRESET_UNDERWATER;
		SoundManager::instance()->System()->setReverbAmbientProperties(&revProp);
	}
	else {
		SoundManager::instance()->getReverb()->setActive(false);	
		FMOD_REVERB_PROPERTIES revProp = FMOD_PRESET_OFF;
		SoundManager::instance()->System()->setReverbAmbientProperties(&revProp);
	}

	SoundManager::instance()->update();

    return true;
	
}

Ogre::Vector3 Test::getCameraMinPos(){	
	return Ogre::Vector3(mCamera->getPosition().x - cameraMin, mCamera->getPosition().y, mCamera->getPosition().z);
	/*return Ogre::Vector3(mCamera->getPosition().x + cameraMax, mCamera->getPosition().y, mCamera->getPosition().z);*/	
}

Ogre::Vector3 Test::getCameraMaxPos(){	
	return Ogre::Vector3(mCamera->getPosition().x + cameraMax, mCamera->getPosition().y, mCamera->getPosition().z);	
}



//End of our codable events.


#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
#define WIN32_LEAN_AND_MEAN
#include "windows.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
    INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
#else
    int main(int argc, char *argv[])
#endif
    {
        // Create application object
        Test app;

        try {
            app.go();
        } catch( Ogre::Exception& e ) {
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
            MessageBox( NULL, e.getFullDescription().c_str(), "An exception has occured!", MB_OK | MB_ICONERROR | MB_TASKMODAL);
#else
            std::cerr << "An exception has occured: " <<
                e.getFullDescription().c_str() << std::endl;
#endif
        }

        return 0;
    }

#ifdef __cplusplus
}
#endif
